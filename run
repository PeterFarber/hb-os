#!/usr/bin/env python3
"""
Automation tool for building and running virtual machine images.
Equivalent to the Makefile tasks, with updated configuration and improved readability.
"""

import os
import sys
import shlex
import argparse
import subprocess
import shutil
import requests

from config.config import config
from src.dependencies import install_dependencies
from src.create_new_vm import create_vm_image
from src.build_initramfs import build_initramfs
from src.build_content import build_guest_content
from src.create_vm_config import create_vm_config_file
from src.setup_guest import setup_guest


# -----------------------------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------------------------
def run_command(cmd):
    """
    Run a shell command and exit if it fails.
    """
    print(f"Running: {cmd}")
    try:
        subprocess.run(cmd, shell=True, check=True)
    except subprocess.CalledProcessError as e:
        print(f"Command failed: {cmd}")
        sys.exit(e.returncode)


# -----------------------------------------------------------------------------
# Initialization & Setup Functions
# -----------------------------------------------------------------------------
def init():
    """
    Initialize the build environment:
      - Create necessary directories.
      - Install dependencies.
      - Download and extract SNP release.
      - Build attestation server and digest calculator.
    """
    
    # Go thru all config.dir and create the directories if they don't exist
    for d in config.dir.__dict__.values():
        if isinstance(d, str):
            os.makedirs(d, exist_ok=True)
            print(f"Ensured directory exists: {d}")

    # Install dependencies.
    install_dependencies(force=False)

    # Download and extract SNP release tarball.
    tarball = os.path.join(config.dir.build, "snp-release.tar.gz")
    url = "https://github.com/SNPGuard/snp-guard/releases/download/v0.1.2/snp-release.tar.gz"
    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        with open(tarball, "wb") as f:
            shutil.copyfileobj(r.raw, f)
    run_command(f"tar -xf {tarball} -C {config.dir.build}")
    run_command(f"rm {tarball}")

    # Build attestation server binaries.
    run_command("cargo build --manifest-path=tools/attestation_server/Cargo.toml")
    for binary in [
        "server",
        "client",
        "get_report",
        "idblock-generator",
        "sev-feature-info",
        "verify_report",
    ]:
        src = os.path.join("tools", "attestation_server", "target", "debug", binary)
        run_command(f"cp {src} {config.dir.bin}")

    # Build digest calculator binary.
    run_command("cargo build --manifest-path=tools/digest_calc/Cargo.toml")
    run_command(f"cp ./tools/digest_calc/target/debug/digest_calc {config.dir.bin}")


def create_vm():
    """
    Create a new virtual machine image using the provided template.
    """
    guest_dir = config.dir.guest
    image_name = config.vm_image_base_name
    template_user_data = config.vm_template_user_data
    create_vm_image(new_vm=image_name, build_dir=guest_dir, template_user_data=template_user_data)


def unpack_kernel():
    """
    Unpack the kernel package from a .deb file.
    """
    kernel_dir = config.dir.kernel
    kernel_deb = config.kernel_deb
    run_command(f"rm -rf {kernel_dir}")
    run_command(f"dpkg -x {kernel_deb} {kernel_dir}")


def initramfs_build():
    """
    Build the initramfs image using the provided script and Dockerfile.
    """
    build_dir = config.dir.build
    resource_dir = config.dir.resources
    kernel_dir = config.dir.kernel
    init_script = config.initramfs_script
    initrd = config.initrd
    dockerfile = config.initramfs_dockerfile

    build_initramfs(
        kernel_dir=kernel_dir,
        init_script=init_script,
        dockerfile=dockerfile,
        context_dir=resource_dir,
        out=initrd,
        build_dir=build_dir,
    )


def setup_vm_config():
    """
    Create the virtual machine configuration file with the required parameters.
    """
    # Build a guest definition dictionary from the flattened config.
    vm_config_definition = {
        "host_cpu_family": config.host_cpu_family,
        "vcpu_count": config.vcpu_count,
        "guest_features": config.guest_features,
        "platform_info": config.platform_info,
        "guest_policy": config.guest_policy,
        "family_id": config.family_id,
        "image_id": config.image_id,
        "min_committed_tcb": config.min_committed_tcb,
    }
    create_vm_config_file(
        out_path=config.vm_config_file,
        ovmf_path=config.ovmf,
        kernel_path=config.kernel_vmlinuz,
        initrd_path=config.initrd,
        kernel_cmdline=f"{config.cmdline} {config.verity_params}",
        vm_config=vm_config_definition,
    )


def get_hashes():
    """
    Generate measurement inputs (hashes) from the VM configuration.
    """
    digest_calc_path = os.path.join(config.dir.bin, "digest_calc")
    out_file = os.path.join(config.dir.build, "measurement-inputs.json")
    run_command(f"{digest_calc_path} --vm-definition {config.vm_config_file} > {out_file}")


# -----------------------------------------------------------------------------
# Build Tasks
# -----------------------------------------------------------------------------
def build_base_image():
    """
    Build the base VM image by:
      1. Unpacking the kernel.
      2. Building the initramfs.
      3. Creating the VM image.
      4. Running QEMU setup.
    """
    print("===> Building base image")
    unpack_kernel()
    initramfs_build()
    create_vm()
    run_setup()


def build_guest_image():
    """
    Build the guest image by:
      1. Building guest content.
      2. Setting up verity.
      3. Creating VM configuration.
      4. Generating hash measurements.
    """
    print("===> Building guest image")
    build_content()
    setup_verity()
    setup_vm_config()
    get_hashes()


def build_content():
    """
    Build the guest content using the provided Dockerfile.
    """
    out_dir = config.dir.content
    dockerfile = config.content_dockerfile
    build_guest_content(out_dir, dockerfile)


def setup_verity():
    """
    Set up verity by running the verity setup shell script.
    """
    setup_guest(
        src_image=config.vm_image_base_path,
        build_dir=config.dir.build,
        out_image=config.verity_image,
        out_hash_tree=config.verity_hash_tree,
        out_root_hash=config.verity_root_hash,
        debug=config.debug,
    )
    
    # os.makedirs(config.dir.verity, exist_ok=True)
    # build_dir = config.dir.build
    # image = config.vm_image_base_path
    # verity_image = config.verity_image
    # verity_hash_tree = config.verity_hash_tree
    # verity_root_hash = config.verity_root_hash
    # debug_flag = config.debug

    # cmd = (
    #     f"./src/setup_verity.sh "
    #     f"-image {image} "
    #     f"-out-image {verity_image} "
    #     f"-out-hash-tree {verity_hash_tree} "
    #     f"-out-root-hash {verity_root_hash} "
    #     f"-build-dir {build_dir} "
    #     f"-debug {debug_flag}"
    # )
    # run_command(cmd)


# -----------------------------------------------------------------------------
# Run and Network Tasks
# -----------------------------------------------------------------------------
def run_setup():
    """
    Run QEMU with the base image configuration.
    """
    cmd = (
        f"sudo -E {config.qemu_launch_script} {config.qemu_default_params} {config.qemu_extra_params} "
        f"-hda {config.vm_image_base_path} -hdb {config.vm_cloud_config} "
        f"-hb-port {config.qemu_hb_port} -qemu-port {config.qemu_port} -debug {config.debug} -enable-kvm {config.enable_kvm}"
    )
    run_command(cmd)


def run_vm():
    """
    Run the VM using QEMU with the guest image configuration.
    """
    cmd = (
        f"sudo -E {config.qemu_launch_script} {config.qemu_default_params} {config.qemu_snp_params} "
        f"-hda {config.verity_image} -hdb {config.verity_hash_tree} -load-config {config.vm_config_file} "
        f"-hb-port {config.qemu_hb_port} -qemu-port {config.qemu_port} -debug {config.debug} -enable-kvm {config.enable_kvm}"
    )
    run_command(cmd)


def setup_host():
    """
    Set up the host system using the SNP release installer.
    """
    snp_release_dir = os.path.join(config.dir.build, "snp-release")
    run_command(f"cd {snp_release_dir} && sudo ./install.sh")


def ssh_vm():
    """
    SSH into the virtual machine.
    """
    vm_port = config.network_vm_port
    ssh_hosts_file = config.ssh_hosts_file
    vm_user = config.network_vm_user
    vm_host = config.network_vm_host
    run_command(f"ssh -p {vm_port} -o UserKnownHostsFile={ssh_hosts_file} {vm_user}@{vm_host}")


# -----------------------------------------------------------------------------
# Stub Tasks for Future Implementation
# -----------------------------------------------------------------------------
def run_release():
    """
    Stub: Run the VM in release mode.
    Currently, this simply calls run_vm.
    """
    print("===> run_release target: Not implemented separately, running run_vm instead.")


def clean():
    """
    Clean up the build directory.
    """
    run_command(f"rm -rf {config.dir.build}")


# -----------------------------------------------------------------------------
# Main Entry Point
# -----------------------------------------------------------------------------
def main():
    """
    Parse command-line arguments and execute the corresponding task.
    """
    parser = argparse.ArgumentParser(
        description="Automation tool equivalent to the Makefile"
    )
    parser.add_argument(
        "target",
        choices=[
            "init",
            "build_base_image",
            "build_guest_image",
            "run",
            "ssh",
            "clean",
        ],
        help="Target task to execute",
    )
    args = parser.parse_args()

    targets = {
        "init": init,
        "setup_host": setup_host,
        "build_base_image": build_base_image,
        "build_guest_image": build_guest_image,
        "run": run_vm,
        "ssh": ssh_vm,
        "clean": clean,
    }

    task = targets.get(args.target)
    if task:
        task()
    else:
        print(f"Unknown target: {args.target}")
        sys.exit(1)


if __name__ == "__main__":
    main()
